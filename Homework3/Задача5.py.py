# Статистика букв
# Напишите функцию letter_stat, которая на вход принимает строку our_str и возвращает словарь letters_dict,
# где в качестве ключей буквы строки, а значениями являются числа,
# соответствующие количеству вхождений данной буквы в строку.
# Например (Ввод --> Вывод) :
# 'letter' --> {'l': 1, 'e': 2, 't': 2, 'r': 1}


def letter_stat(our_str):
    """
    Данная функция итерирует по строке - our_str
    и добавляет в пустой словарь значение ключа "get"
    увеличивая значение ключа за каждую найденную букву
    :param our_str:
    :return:
    """
    # Здесь нужно написать код
    letters_dict = {}
    for x in our_str:
        letters_dict[x] = letters_dict.get(x, 0) + 1
    return letters_dict

# Ниже НИЧЕГО НЕ НАДО ИЗМЕНЯТЬ


data = ['letter', "honduras", "тегусигальпа", "автотестирование", "тензор", "управлениекачеством", 'мануальщик', '',
        'курс', 'ы', 'лол', 'кек']

test_data = [{'l': 1, 'e': 2, 't': 2, 'r': 1}, {'h': 1, 'o': 1, 'n': 1, 'd': 1, 'u': 1, 'r': 1, 'a': 1, 's': 1},
             {'т': 1, 'е': 1, 'г': 2, 'у': 1, 'с': 1, 'и': 1, 'а': 2, 'л': 1, 'ь': 1, 'п': 1},
             {'а': 2, 'в': 2, 'т': 3, 'о': 2, 'е': 2, 'с': 1, 'и': 2, 'р': 1, 'н': 1},
             {'т': 1, 'е': 1, 'н': 1, 'з': 1, 'о': 1, 'р': 1},
             {'у': 1, 'п': 1, 'р': 1, 'а': 2, 'в': 2, 'л': 1, 'е': 3, 'н': 1, 'и': 1, 'к': 1,
              'ч': 1, 'с': 1, 'т': 1, 'о': 1, 'м': 1},
             {'м': 1, 'а': 2, 'н': 1, 'у': 1, 'л': 1, 'ь': 1, 'щ': 1, 'и': 1, 'к': 1},
             {},
             {'к': 1, 'у': 1, 'р': 1, 'с': 1},
             {'ы': 1}, {'л': 2, 'о': 1}, {'к': 2, 'е': 1}
             ]

for i, d in enumerate(data):
    assert letter_stat(d) == test_data[i], f'С набором {d} есть ошибка, не проходит проверку'
    print(f'Тестовый набор {d} прошёл проверку')
print('Всё ок')

# Повторяшки
# Напишите функцию repeats, которая принимает на вход строку our_str,
# смотрит, сколько раз каждый символ уже встречался, и добавляет количество к символам с помощью постфикса формата _n.
# Возвращается новая строка
# Например (Ввод --> Вывод):
# 'letter' --> l_1e_1t_1t_2e_2_r_1


def repeats(our_str):
    """
    Данная функция итерирует по строке - our_str
    И выводит форматированный текст вида - ключ(x - буква)_значение ключа (letters_dict[x] - цифра каждой отдельной буквы)
    :param our_str:
    :return:
    """
    # Здесь нужно написать код
    letters_dict = {}
    new_str = ""
    for x in our_str:
        letters_dict[x] = letters_dict.get(x, 0) + 1
        new_str += f"{x}_{letters_dict[x]}"
    return new_str

# Ниже НИЧЕГО НЕ НАДО ИЗМЕНЯТЬ


data = ['letter', "карабасбарабас", "околоводопроводного", "еженедельное", "Караганда", "контрреформатор",
        'аббревиатура', '', 'чечевичечка', 'колокольчик', 'контрреволюционер', 'длинношеее']

test_data = ['l_1e_1t_1t_2e_2r_1',
             'к_1а_1р_1а_2б_1а_3с_1б_2а_4р_2а_5б_3а_6с_2',
             'о_1к_1о_2л_1о_3в_1о_4д_1о_5п_1р_1о_6в_2о_7д_2н_1о_8г_1о_9',
             'е_1ж_1е_2н_1е_3д_1е_4л_1ь_1н_2о_1е_5',
             'К_1а_1р_1а_2г_1а_3н_1д_1а_4',
             'к_1о_1н_1т_1р_1р_2е_1ф_1о_2р_3м_1а_1т_2о_3р_4',
             'а_1б_1б_2р_1е_1в_1и_1а_2т_1у_1р_2а_3',
             '',
             'ч_1е_1ч_2е_2в_1и_1ч_3е_3ч_4к_1а_1',
             'к_1о_1л_1о_2к_2о_3л_2ь_1ч_1и_1к_3',
             'к_1о_1н_1т_1р_1р_2е_1в_1о_2л_1ю_1ц_1и_1о_3н_2е_2р_3',
             'д_1л_1и_1н_1н_2о_1ш_1е_1е_2е_3'
             ]

for i, d in enumerate(data):
    assert repeats(d) == test_data[i], f'С набором {d} есть ошибка, не проходит проверку'
    print(f'Тестовый набор {d} прошёл проверку')
print('Всё ок')
# Игра "Эрудит"
# Нужно написать программу scrabble, которая помогает считать кол-во очков (points), полученное за слово (word)
# По одному очку вы получите за буквы а, в, е=ё, и, н, о, р, с, т.
# Два очка стоит д, к, л, м, п, у.
# Три балла получают за б, г, ь, а также я.
# Четыре балла стоят буквы й, ы.
# 5 очков засчитывается за ж, з, х, ц, ч.
# 6 и 7 очков не предусмотрено.
# Восемь можно получить за букву ф, ш, э, ю.
# 10 баллов стоит буква щ,
# а 15 - ъ
# Например (Ввод --> Вывод):
# курс --> 6 (к=2, у=2, р=1, с=1)


def scrabble(word):
    """
    Данная функция считает "баллы" каждой буквы
    И выводит их сумму
    :param word:
    :return:
    """
    # Здесь нужно написать код
    summ = {"а": 1, "в": 1, "е": 1, "ё": 1, "и": 1, "н": 1, "о": 1, "р": 1, "с": 1, "т": 1, "д": 2, "к": 2, "л": 2,
            "м": 2, "п": 2, "у": 2, "б": 3, "г": 3, "ь": 3,
            "я": 3, "й": 4, "ы": 4, "ж": 5, "з": 5, "х": 5, "ц": 5, "ч": 5, "ф": 8, "ш": 8, "э": 8, "ю": 8, "щ": 10,
            "ъ": 15}
    points = 0
    for x in word:
        points += int(summ.get(x))
    return points

# Ниже НИЧЕГО НЕ НАДО ИЗМЕНЯТЬ


data = ["курс", 'авеинорстё', 'дклмпеу', 'бгья', 'йы', 'жзхцч', 'фшэю', 'щъ', "карабасбарабас", "околоводопроводного",
        "еженедельное", 'эхоэнцефалограф', 'человеконенавистничество', 'делопроизводительница']

test_data = [6, 10, 13, 12, 8, 25, 32, 25, 21, 26, 20, 54, 34, 36]

for i, d in enumerate(data):
    assert scrabble(d) == test_data[i], f'С набором {d} есть ошибка, не проходит проверку'
    print(f'Тестовый набор {d} прошёл проверку')
print('Всё ок')
# Котики и их человеки
# В зоомагазине "Всё для вашей киски" есть книга о котах и покупателях - cats_data.
# Данные о кошках и их владельцах записаны списком кортежей,
# где каждый кортеж состоит из: Кличка котика, Возраст котика, Имя покупателя, Фамилия покупателя.
# Имена некоторых владельцев повторяются, потому что у них несколько кошек.
# Необходимо оптимизировать хранение данных таким образом, чтобы для каждого владельца при выводе (одна строка)
# данные о всех его животных отображались в одной строке, на новой строке следующий покупатель и все его питомцы и т.д.
# Формат для одного покупателя:
# Имя_покупателя Фамилия_покупателя: Кличка_котика1, Возраст; ...; Кличка_котикаN, Возраст\n
# Например (Ввод --> Вывод):
# Ввод
# [('Мартин', 5, 'Алексей', 'Егоров'),
#  ('Фродо', 3, 'Анна', 'Самохина'),
#  ('Вася', 4, 'Алексей', 'Егоров')]
# Вывод
# Алексей Егоров: Мартин, 5; Вася, 4
# Анна Самохина: Фродо, 3
#


def everything_for_your_cat(cats_data):
    """
    Данная функция обрабатывает кортеж с хозяевами (в т.ч одинковыми) и разными котами
    Высчитывает по индексу где коты, а где хозяева
    Добавляет новых котов в строку с хозяином
    И выводит строку вида хозяин --> Все его коты (игнорируя дубли хозяев)
    :param cats_data:
    :return:
    """
    # Здесь нужно написать код
    kot = {}
    our_str = ""
    for x in cats_data:
        fio = f"{x[2]} {x[3]}"
        if fio not in kot:
            kot[fio] = []
        kot[fio].append(f"{x[0]}, {x[1]}")
    for fio, kot in kot.items():
        our_str += f"{fio}: {'; '.join(kot)}\n"
    return our_str

# Ниже НИЧЕГО НЕ НАДО ИЗМЕНЯТЬ


data = [[('Мартин', 5, 'Алексей', 'Егоров'),
         ('Фродо', 3, 'Анна', 'Самохина'),
         ('Вася', 4, 'Алексей', 'Егоров')],
        [('Мартин', 5, 'Алексей', 'Егоров'),
         ('Фродо', 3, 'Анна', 'Самохина'),
         ('Вася', 4, 'Андрей', 'Белов'),
         ('Муся', 7, 'Игорь', 'Бероев'),
         ('Изольда', 2, 'Игорь', 'Бероев'),
         ('Снейп', 1, 'Марина', 'Апраксина'),
         ('Лютик', 4, 'Виталий', 'Соломин'),
         ('Снежок', 3, 'Марина', 'Апраксина'),
         ('Марта', 5, 'Сергей', 'Колесников'),
         ('Буся', 12, 'Алена', 'Федорова'),
         ('Джонни', 10, 'Игорь', 'Андропов'),
         ('Мурзик', 1, 'Даниил', 'Невзоров'),
         ('Барсик', 2, 'Виталий', 'Соломин'),
         ('Рыжик', 7, 'Владимир', 'Медведев'),
         ('Матильда', 8, 'Андрей', 'Белов'),
         ('Гарфилд', 3, 'Александр', 'Березуев')],
        [('Мартин', 5, 'Алексей', 'Егоров'),
         ('Фродо', 3, 'Анна', 'Самохина'),
         ('Вася', 4, 'Андрей', 'Белов'),
         ('Муся', 7, 'Игорь', 'Бероев'),
         ('Изольда', 2, 'Игорь', 'Бероев'),
         ('Снейп', 1, 'Игорь', 'Бероев'),
         ('Лютик', 4, 'Игорь', 'Бероев'),
         ('Снежок', 3, 'Игорь', 'Бероев'),
         ('Марта', 5, 'Андрей', 'Белов'),
         ('Буся', 12, 'Анна', 'Самохина'),
         ('Джонни', 10, 'Андрей', 'Белов'),
         ('Мурзик', 1, 'Алексей', 'Егоров'),
         ('Барсик', 2, 'Андрей', 'Белов'),
         ('Рыжик', 7, 'Анна', 'Самохина'),
         ('Матильда', 8, 'Андрей', 'Белов'),
         ('Гарфилд', 3, 'Алексей', 'Егоров')],
        [], [('Гарфилд', 3, 'Алексей', 'Егоров')]
        ]

test_data = ['''Алексей Егоров: Мартин, 5; Вася, 4
Анна Самохина: Фродо, 3
''',
             '''Алексей Егоров: Мартин, 5
Анна Самохина: Фродо, 3
Андрей Белов: Вася, 4; Матильда, 8
Игорь Бероев: Муся, 7; Изольда, 2
Марина Апраксина: Снейп, 1; Снежок, 3
Виталий Соломин: Лютик, 4; Барсик, 2
Сергей Колесников: Марта, 5
Алена Федорова: Буся, 12
Игорь Андропов: Джонни, 10
Даниил Невзоров: Мурзик, 1
Владимир Медведев: Рыжик, 7
Александр Березуев: Гарфилд, 3
''',
             '''Алексей Егоров: Мартин, 5; Мурзик, 1; Гарфилд, 3
Анна Самохина: Фродо, 3; Буся, 12; Рыжик, 7
Андрей Белов: Вася, 4; Марта, 5; Джонни, 10; Барсик, 2; Матильда, 8
Игорь Бероев: Муся, 7; Изольда, 2; Снейп, 1; Лютик, 4; Снежок, 3
''', '', '''Алексей Егоров: Гарфилд, 3
''']

for i, d in enumerate(data):
    assert everything_for_your_cat(d) == test_data[i], f'С набором {d} есть ошибка, не проходит проверку'
    print(f'Тестовый набор {d} прошёл проверку')
print('Всё ок')
